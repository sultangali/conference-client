import { configureStore, createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import { createSelector } from 'reselect';
import axios from './../utils/axios.js';

// –õ–æ–∫–∞–ª–∏–∑–∞—Ü–∏—è: —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —è–∑—ã–∫–æ–≤—ã–º–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏
const localizationSlice = createSlice({
  name: 'localization',
  initialState: { language: 'ru' }, // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫
  reducers: {
    setLanguage: (state, action) => {
      state.language = action.payload; // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—ã–±—Ä–∞–Ω–Ω—ã–π —è–∑—ã–∫
    },
  },
});

// –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π —ç–∫—à–µ–Ω –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
export const registerUser = createAsyncThunk(
  'user/register',
  async (userData, { rejectWithValue }) => {
    try {
      const response = await axios.post('/user/auth/register', userData);
      return response.data;
    } catch (error) {
      return rejectWithValue(error.response.data);
    }
  }
);

// –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π —ç–∫—à–µ–Ω –¥–ª—è –ª–æ–≥–∏–Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
export const loginUser = createAsyncThunk(
  'user/login',
  async (credentials, { rejectWithValue }) => {
    try {
      console.log("üîπ –û—Ç–ø—Ä–∞–≤–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ –Ω–∞ –ª–æ–≥–∏–Ω:", credentials);
      const response = await axios.post('/api/user/auth/login', credentials);
      console.log("‚úÖ –û—Ç–≤–µ—Ç —Å–µ—Ä–≤–µ—Ä–∞:", response.data);
      return response.data;
    } catch (error) {
      console.log("‚ùå –û—à–∏–±–∫–∞ –ª–æ–≥–∏–Ω–∞:", error.response);
      return rejectWithValue(error.response.data);
    }
  }
);


// –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π —ç–∫—à–µ–Ω –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –ø—Ä–æ—Ñ–∏–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
export const fetchUserProfile = createAsyncThunk(
  'user/fetchProfile',
  async (_, { rejectWithValue }) => {
    try {
      const response = await axios.get('/api/user/me'); // ‚úÖ –ü–†–ê–í–ò–õ–¨–ù–´–ô URL
      return response.data;
    } catch (error) {
      return rejectWithValue(error.response?.data || "–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ø—Ä–æ—Ñ–∏–ª—è");
    }
  }
);


export const fetchAuthMe = createAsyncThunk('auth/fetchAuthMe', async () => {
  const { data } = await axios.get('/api/user/me');
  return data;
});

// –≠–∫—à–µ–Ω –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ —Å–ø–∏—Å–∫–∞ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤
export const fetchParticipants = createAsyncThunk(
  "user/fetchParticipants",
  async (_, { rejectWithValue }) => {
    try {
      const response = await axios.get("/api/user/participants");
      return response.data;
    } catch (error) {
      return rejectWithValue(error.response.data);
    }
  }
);

// –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–µ–π –∏ –ø—Ä–æ—Ñ–∏–ª–µ–º
const userSlice = createSlice({
  name: 'user',
  initialState: {
    isAuthenticated: false, // –°—Ç–∞—Ç—É—Å –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
    role: null, // –†–æ–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: 'correspondent', 'coauthor', 'moderator'
    profile: {}, // –î–∞–Ω–Ω—ã–µ –ø—Ä–æ—Ñ–∏–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    data: null,
    participants: [],
    verified: false, // –§–ª–∞–≥ –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏–∏
    loading: false,
    message: '',
    error: null,
  },
  reducers: {
    logout: (state) => {
      state.isAuthenticated = false; // –í—ã—Ö–æ–¥ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
      state.role = null;
      state.profile = {};
    },
    verifyUser: (state) => {
      state.verified = true; // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏—é
    },
  },
  extraReducers: (builder) => {
    builder
      .addCase(registerUser.pending, (state) => {
        state.loading = true;
      })
      .addCase(registerUser.fulfilled, (state, action) => {
        state.loading = false;
        state.isAuthenticated = true;
        state.data = action.payload;
        state.profile = action.payload;
      })
      .addCase(registerUser.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      })
      .addCase(loginUser.pending, (state) => {
        state.loading = true;
      })
      .addCase(loginUser.fulfilled, (state, action) => {
        state.loading = false;
        state.isAuthenticated = true;
        state.data = action.payload;
        state.profile = action.payload;
        state.message = action.payload; //—ç—Ç–æ —è –¥–æ–±–∞–≤–∏–ª —Ç—É—Ç —è —Ö–æ—á—É –≤ —Å–ª—É—á–∞–µ —á–µ–≥–æ –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å –æ—Ç–≤–µ—Ç—ã –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞ 
      })
      .addCase(loginUser.rejected, (state, action) => {
        state.loading = false;
        state.message = action.payload;
        state.error = action.payload;
      })
      .addCase(fetchUserProfile.fulfilled, (state, action) => {
        state.profile = action.payload;
      })
      .addCase(fetchAuthMe.fulfilled, (state, action) => {
        state.isAuthenticated = true;
        state.data = action.payload;
        state.profile = action.payload;
      })
      .addCase(fetchAuthMe.rejected, (state) => {
        state.isAuthenticated = false;
      })
      .addCase(fetchParticipants.pending, (state) => {
        state.loading = true;
      })
      .addCase(fetchParticipants.fulfilled, (state, action) => {
        state.loading = false;
        state.participants = action.payload;
      })
      .addCase(fetchParticipants.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      });
  },
});

// –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π —ç–∫—à–µ–Ω –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –ª–æ–≥–∏–Ω–æ–≤ –∏ –ø–∞—Ä–æ–ª–µ–π —Å–æ–∞–≤—Ç–æ—Ä–æ–≤ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ
export const generateCoauthorCredentials = createAsyncThunk(
  'conference/generateCoauthorCredentials',
  async (authors) => {
    const response = await axios.post('/api/generate-coauthors', { authors });
    return response.data; // –°–µ—Ä–≤–µ—Ä –≤–µ—Ä–Ω–µ—Ç –º–∞—Å—Å–∏–≤ –ª–æ–≥–∏–Ω–æ–≤ –∏ –ø–∞—Ä–æ–ª–µ–π
  }
);

// –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π —ç–∫—à–µ–Ω –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ —Å—Ç–∞—Ç–µ–π
export const fetchPapers = createAsyncThunk(
  'conference/fetchPapers',
  async (_, { rejectWithValue }) => {
    try {
      const response = await axios.get('/api/papers');
      return response.data;
    } catch (error) {
      return rejectWithValue(error.response.data);
    }
  }
);

// –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π —ç–∫—à–µ–Ω –¥–ª—è –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–æ–≤ (–ø—Ä–∏–Ω—è—Ç–∏–µ/–æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ —Å—Ç–∞—Ç—å–∏)
export const updatePaperStatus = createAsyncThunk(
  'conference/updatePaperStatus',
  async ({ paperId, status }, { rejectWithValue }) => {
    try {
      const response = await axios.put(`/api/papers/${paperId}/status`, { status });
      return response.data;
    } catch (error) {
      return rejectWithValue(error.response.data);
    }
  }
);

// –ö–æ–Ω—Ñ–µ—Ä–µ–Ω—Ü–∏—è: —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —ç—Ç–∞–ø–∞–º–∏ –∏ —Å—Ç–∞—Ç—å—è–º–∏
const conferenceSlice = createSlice({
  name: 'conference',
  initialState: {
    steps: {
      problemSubmissionOpen: true, // –≠—Ç–∞–ø –ø–æ–¥–∞—á–∏ –∑–∞–¥–∞—á –æ—Ç–∫—Ä—ã—Ç –¥–æ 1 –º–∞—Ä—Ç–∞ 2025
      problemSolvingOpen: false, // –≠—Ç–∞–ø —Ä–µ—à–µ–Ω–∏—è –ø—Ä–æ–±–ª–µ–º –æ—Ç–∫—Ä–æ–µ—Ç—Å—è –ø–æ—Å–ª–µ 1 –º–∞—Ä—Ç–∞ 2025
      discussionOpen: false, // –î–∏—Å–∫—É—Å—Å–∏–∏ –∏ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏ —Å 18-19 –∏—é–Ω—è 2025
    },
    papers: [], // –°–ø–∏—Å–æ–∫ —Å—Ç–∞—Ç–µ–π
    loading: false,
    error: null,
  },
  reducers: {
    setStep: (state, action) => {
      state.steps = { ...state.steps, ...action.payload }; // –û–±–Ω–æ–≤–ª—è–µ–º —ç—Ç–∞–ø –∫–æ–Ω—Ñ–µ—Ä–µ–Ω—Ü–∏–∏
    },
  },
  extraReducers: (builder) => {
    builder
      .addCase(generateCoauthorCredentials.fulfilled, (state, action) => {
        const { paperId, coauthors } = action.payload;
        const paper = state.papers.find((p) => p.id === paperId);
        if (paper) {
          paper.coauthors = coauthors;
        }
      })
      .addCase(fetchPapers.fulfilled, (state, action) => {
        state.papers = action.payload;
      })
      .addCase(updatePaperStatus.fulfilled, (state, action) => {
        const { paperId, status } = action.payload;
        const paper = state.papers.find((p) => p.id === paperId);
        if (paper) {
          paper.status = status;
        }
      });
  },
});


export const fetchProblems = createAsyncThunk(
  "articles/fetchProblems",
  async (_, { rejectWithValue }) => {
    try {
      const response = await axios.get("/api/articles/problems");
      return response.data;
    } catch (error) {
      return rejectWithValue(error.response.data);
    }
  }
);

export const createSolveArticle = createAsyncThunk(
  "article/createSolve",
  async (articleData, { rejectWithValue }) => {
    try {
      const { data } = await axios.post("/api/articles/solve", articleData);
      return data;
    } catch (error) {
      return rejectWithValue(error.response.data);
    }
  }
);

const articleSlice = createSlice({
  name: "articles",
  initialState: {
    problems: [],
    loading: false,
    data: null,
    error: null,
  },
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchProblems.pending, (state) => {
        state.loading = true;
      })
      .addCase(fetchProblems.fulfilled, (state, action) => {
        state.loading = false;
        state.problems = action.payload;
      })
      .addCase(fetchProblems.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      })
      .addCase(createSolveArticle.pending, (state) => {
        state.loading = true;
      })
      .addCase(createSolveArticle.fulfilled, (state, action) => {
        state.loading = false;
        state.data = action.payload;
      })
      .addCase(createSolveArticle.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      });
  },
});


// –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è Redux Store
const store = configureStore({
  reducer: {
    localization: localizationSlice.reducer, // –õ–æ–∫–∞–ª–∏–∑–∞—Ü–∏—è
    user: userSlice.reducer, // –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ –¥–∞–Ω–Ω—ã–µ
    conference: conferenceSlice.reducer, // –î–∞–Ω–Ω—ã–µ –∫–æ–Ω—Ñ–µ—Ä–µ–Ω—Ü–∏–∏
    article: articleSlice.reducer
  },
});

// –≠–∫—Å–ø–æ—Ä—Ç –¥–µ–π—Å—Ç–≤–∏–π –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞—Ö
export const { setLanguage } = localizationSlice.actions;
export const { logout, verifyUser } = userSlice.actions;

export const selectIsAuth = (state) => {
  console.log("üîπ –ü—Ä–æ–≤–µ—Ä–∫–∞ isAuthenticated:", state.user.isAuthenticated);
  return state.user.isAuthenticated
};

export const { setStep } = conferenceSlice.actions;
export default store;
